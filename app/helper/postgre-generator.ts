import { DiagramData } from "../type/DiagramType";
import { ErdEdgeData } from "../type/EdgeType";
import { AttributeData, EntityData } from "../type/EntityType";

function mapDataType(column: AttributeData): string {
    const typeMap: Record<string, string> = {
        boolean: "BOOLEAN",
        smallint: "SMALLINT",
        integer: "INTEGER",
        largeint: "BIGINT",
        float: "REAL",
        double: "DOUBLE PRECISION",
        numeric: "NUMERIC",

        string: "VARCHAR",
        text: "TEXT",
        uuid: "UUID",

        date: "DATE",
        time: "TIMEZ",
        datetime: "TIMESTAMPTZ",
        timestamp: "TIMESTAMPTZ",

        json: "JSON",
        geometry: "GEOMETRY",
        geography: "GEOGRAPHY",
    };

    let type = typeMap[column.type.toLowerCase()];
    if (column.type.toLowerCase() === "string") {
        const len = column.length || 255;
        type += `(${len})`;
    } else if (column.type.toLowerCase() === "numeric") {
        const precision = column.precision || 10;
        const scale = column.scale || 0;
        type += `(${precision}, ${scale})`;
    }

    return type;
}

function createFieldPostgreSql(column: AttributeData): string {
    let sql = `    ${column.name} ${mapDataType(column)}`;

    if (column.isAutoIncrement) {
        if (
            [
                "smallint",
                "integer",
                "largeint",
                "float",
                "double",
                "numeric",
            ].indexOf(column.type) > -1
        ) {
            sql += " GENERATED BY DEFAULT AS IDENTITY";
        }
    }

    if (column.isPrimaryKey) {
        sql += " PRIMARY KEY";
    } else if (column.isUnique) {
        sql += " UNIQUE";
    }

    if (column.isNullable === false) {
        sql += " NOT NULL";
    }

    if (!column.isAutoIncrement) {
        if (
            (column.type === "timestamp" || column.type === "datetime") &&
            column.isCurrent
        ) {
            sql += " DEFAULT CURRENT_TIMESTAMP";
        } else if (column.type === "date" && column.isCurrent) {
            sql += ` DEFAULT CURRENT_DATE`;
        } else if (column.type === "time" && column.isCurrent) {
            sql += ` DEFAULT CURRENT_TIME`;
        } else if (column.defaultValue !== undefined) {
            let defaultVal = ["string", "text"].includes(column.type)
                ? `'${column.defaultValue}'`
                : column.defaultValue;
            if (column.defaultValue === null) {
                defaultVal = "NULL";
            }
            sql += ` DEFAULT ${defaultVal}`;
        }
    }

    if (column.isUnicode) {
        sql += ` COLLATE "en_US.utf8"`;
    }

    return sql;
}

function createTablePostgreSql(entity: EntityData): string {
    const tableName = entity.name;
    const columns = entity.attributes.map(createFieldPostgreSql);

    let sql = `CREATE TABLE IF NOT EXISTS ${tableName} (\n${columns.join(
        ",\n"
    )}\n);`;

    entity.attributes.forEach((attr) => {
        if (attr.description) {
            sql += `\nCOMMENT ON COLUMN ${tableName}.${attr.name} IS '${attr.description}';`;
        }
    });

    return sql;
}

function createForeignKeyPostgreSql(edge: ErdEdgeData): string {
    const {
        primaryKeyColumn,
        primaryKeyTable,
        foreignKeyColumn,
        foreignKeyTable,
        onDelete,
        onUpdate,
    } = edge;
    if (
        !primaryKeyColumn ||
        !primaryKeyTable ||
        !foreignKeyColumn ||
        !foreignKeyTable
    ) {
        return "";
    }

    let cascade = "";
    if (onDelete) {
        cascade += ` ON DELETE ${onDelete}`;
    }
    if (onUpdate) {
        cascade += ` ON UPDATE ${onUpdate}`;
    }
    return `ALTER TABLE ${foreignKeyTable} ADD CONSTRAINT fk_${foreignKeyTable}_${primaryKeyTable} FOREIGN KEY (${foreignKeyColumn}) REFERENCES ${primaryKeyTable}(${primaryKeyColumn})${cascade};`;
}

export function generatePostgreSql(
    nodesData: EntityData[],
    edgesData: ErdEdgeData[]
): string {
    // const nodes = diagram.history.states[diagram.history.current].nodes
    // const edges = diagram.history.states[diagram.history.current].edges;
    console.log("Generating PostgreSQL:", { nodesData, edgesData });
    const sqlStatements: string[] = [];
    nodesData.forEach((nd) => {
        const createTableSql = createTablePostgreSql(nd);
        sqlStatements.push(createTableSql);
    });
    edgesData.forEach((ed) => {
        if (!ed) return;
        const createForeignKeySql = createForeignKeyPostgreSql(ed);
        if (createForeignKeySql) {
            sqlStatements.push(createForeignKeySql);
        }
    });

    return sqlStatements.join("\n\n");
}

export function generateInsertsPostgreSql(data: any): string {
    const insertStatements: string[] = [];

    for (const entityName in data) {
        const list = data[entityName];

        for (const item of list) {
            const keys = Object.keys(item);
            const values = Object.values(item);

            const sql = `INSERT INTO ${entityName} (${keys.join(
                ", "
            )}) \nVALUES (${values
                .map((v) => {
                    if(v === null) {
                        return "NULL";
                    }
                    return typeof v === "string" ? `'${escapeSingleQuotes(v)}'` : v;
                })
                .join(", ")});`;
            insertStatements.push(sql);
        }
        insertStatements.push("\n\n");
    }

    return insertStatements.join("\n");
}

function escapeSingleQuotes(str: string): string {
  return str.replace(/'/g, "\\'");
}